---
title: "Lab 2 - Data wrangling"
author: "Sheila Yu"
date: "Feburary 4th, 2026"
format: html
---

```{r}
#| eval: true
#| message: false

library(tidyverse)
data <- midwest
```

# Questions

## Part 1

### Question 1

```{r}
counties_by_state <- data %>%
  count(state, name = "n_counties") %>%
  arrange(desc(n_counties))

counties_by_state

```

The code above displays calculation the number of counties in each state. Based on the calculation, Illinois (IL) has the highest number of counties, with a total of 102 counties. Wisconsin (WI) has the lowest number of counties, with a total of 72 counties.

\newpage

### Question 2

```{r}
data %>%
  count(county, name = "n_states") %>%
  filter(n_states == n_distinct(midwest$state))
```

Based on the result above, the county that fills in the blank of “Look at that, there is a county called \_\_\_ in each state in this dataset!” includes Crawford, Jackson and Monroe.

\newpage

### Question 3

Part a:

```{r}
data %>%
  filter(popdensity > 25000) %>%
  select(county, state, popdensity, poptotal, area) %>%
  arrange(desc(popdensity))
```

Based on the results above, there are a total of nine counties with a population density above 25,000. These counties include: Cook, Milwaukee, Wayne, Cuyahoga, Du Page, Marion, Hamilton, Franklin and Macomb.

Part b:

```{r}
data %>%
  filter(popdensity == max(popdensity, na.rm = TRUE)) %>%
  select(county, state, popdensity, poptotal, area)
```

Based on the result above, the county with the highest population density is Cook.

\newpage

### Question 4

```{r}
data %>%
  summarise(
    median_density = median(popdensity, na.rm = TRUE),
    q1 = quantile(popdensity, 0.25, na.rm = TRUE),
    q3 = quantile(popdensity, 0.75, na.rm = TRUE)
  )
```

The distribution of population density of counties is unimodal and extremely right-skewed. A typical Midwestern county has population density of 1156 people per unit area. The middle 50% of the counties have population densities between 622 to 2330 people per unit area.

\*Please note that the data are rounded to the nearest whole number.

\newpage

### Question 5

```{r}
data %>%
  mutate(metro = if_else(inmetro == 1, "Yes", "No")) %>%
  count(state, metro) %>%
  group_by(state) %>%
  mutate(proportion = n / sum(n)) %>%
  ungroup()
```

Here is a table with results from the calculation above displayed and rounded of to nearest percentage:

| State | Metro or not | Proportion of population in the area |
|-------|--------------|--------------------------------------|
| IL    | No           | 73%                                  |
| IL    | Yes          | 27%                                  |
| IN    | No           | 60%                                  |
| IN    | Yes          | 40%                                  |
| MI    | No           | 70%                                  |
| MI    | Yes          | 30%                                  |
| OH    | No           | 55%                                  |
| OH    | Yes          | 45%                                  |
| WI    | No           | 72%                                  |
| WI    | Yes          | 28%                                  |

\newpage

### Question 6

Part a:

```{r}
data %>%
  filter(
    percollege < 12,
    percbelowpoverty > 45
  ) %>%
  select(county, state, percbelowpoverty, percollege)
```

The outlier in the orange square is the county Menominee.

Part b:

```{r}
data %>%
  filter(
    percollege > 40,
    percbelowpoverty < 20
  ) %>%
  select(county, state, percbelowpoverty, percollege)
```

The outliers in the red square are: Champaign, Du Page, Hamilton, Washtenaw, Dane.

Part c:

```{r}
data %>%
  filter(
    (percollege < 12 & percbelowpoverty > 45) |
    (percollege > 40 & percbelowpoverty < 20)
  ) %>%
  select(county, state, percbelowpoverty, percollege)
```

Above is a list of all the outliers in the orange and red square combined.

Part d:

```{r}
midwest <- midwest %>%
  mutate(
    potential_outlier = if_else(
      (percollege < 12 & percbelowpoverty > 45) |
      (percollege > 40 & percbelowpoverty < 20),
      "Yes",
      "No"
    )
  )

midwest %>%
  select(county, state, percbelowpoverty, percollege, potential_outlier) %>%
  arrange(potential_outlier)
```

The updated dataset, *midwest*, now contains an additional column called potential_outlier, which indicates whether a county is included in the list of potential outliers identified in part c.

Part e:

```{r}
ggplot(midwest, aes(x = percollege, y = percbelowpoverty, color = potential_outlier)) +
  geom_point(alpha = 0.7) +
  labs(
    x = "Percentage with a college degree",
    y = "Percentage below poverty",
    title = "Percentage with a college degree versus poverty rate",
    subtitle = "Potential outliers highlighted"
  ) +
  theme_minimal()
```

Above is the visualization of the relationship between college education and poverty, with colour highlighting the potential outliers in blue.

\newpage

### Question 7

Part a:

```{r}
state_population <- midwest %>%
  group_by(state) %>%
  summarise(total_population = sum(poptotal, na.rm = TRUE)) %>%
  arrange(desc(total_population))

state_population
```

Part b:

```{r}
state_population %>%
  mutate(
    population_proportion = total_population / sum(total_population)
  ) %>%
  arrange(desc(population_proportion))

```

Part c: Illinois is the most populous Midwestern state, containing 27% of the total Midwest population. Wisconsin is the least populous state, accounting for only 12% of the Midwest population.

\newpage

### Question 8

```{r}
state_poverty <- midwest %>%
  group_by(state) %>%
  summarise(
    mean_percbelowpoverty = mean(percbelowpoverty, na.rm = TRUE)
  )

state_poverty %>%
  arrange(mean_percbelowpoverty)
```

Based on the result above, Wisconsin has the lowest average percentage of population (10%) below the poverty line across its counties. Mississippi has the highest average percentage of population (14%) below the poverty line across its counties.

\newpage

## Part 2

Setting up data frame:

```{r}
df <- tibble(
  var_1 = c(10, 20, 30, 40, 50),
  var_2 = c("Pizza", "Burger", "Pizza", "Pizza", "Burger"),
  var_3 = c("Apple", "Apple", "Pear", "Pear", "Banana")
)

df

```

### Question 9

Part a:

```{r}
df |>
  arrange(var_2)
```

The arrange () function reorders the rows of the data frame alphabetically by data in the column var_2.

Part b:

```{r}
df |>
  group_by(var_2)
```

The group_by () function groups the data frame by the variable var_2. It doesn't change the appearance of the data set, but it does createsgroups internally so that subsequent operations are performed separately for each group.

Part c:

```{r}
df |>
  group_by(var_2) |>
  summarize(mean_var_1 = mean(var_1))
```

The pipeline first groups the data by var_2, then calculates the mean of var_1 within each group that is created. Therefore it computes the mean of var_1 separately for each category in var_2.

Part d:

```{r}
df |>
  group_by(var_2, var_3) |>
  summarize(mean_var_1 = mean(var_1))
```

This pipeline groups the data frame by both var_2 and var_3, and then calculates the mean of var_1 within each unique combination of var_2 and var_3. The message displays:

```         
`summarise()` has grouped output by 'var_2'. You can override using the `.groups`
argument.
```

It indicates that after applying the summarize () function, the resulting data frame remains grouped by var_2. The message also notes that this behavior can be overridden by specifying the .groups argument, if an ungrouped output is desired.

Part e:

```{r}
df |>
  group_by(var_2, var_3) |>
  summarize(mean_var_1 = mean(var_1), .groups = "drop")
```

This pipeline repeats the same grouped mean calculation as part d, but the .groups = "drop" argument tells summarize () to remove all grouping from the output, thereby un-grouping the output. Compared to the output in part d, the output in part 3 results in tibbles that is not grouped. No message (as shown in part d) is showing, suggesting that the output is a regular ungrouped data frame. However, it is also worth to note that the rows and values are the same in both part d and e.

Part f:

```{r}
df |>
  group_by(var_2, var_3) |>
  summarize(mean_var_1 = mean(var_1), .groups = "drop")

df |>
  group_by(var_2, var_3) |>
  mutate(mean_var_1 = mean(var_1))
```

Pipeline 1 collapses the data and returns one row per group (var_2, var_3) with the mean of var_1. On the other hand, pipeline 2 does not collapse the data. Instead, it keeps all original rows, but adds a new column (mean_var_1) on top of existing rows where every row in the same group gets the same group mean value.
